<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2016ドキュメント(2016年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．チュートリアル</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>００５．衝突判定と自動反発</h3>
<br />
<h4>自動反発</h4>
　Tutorial005のソリューションを開いてリビルド、実行すると以下のような画面になります（コントローラで少し引いた画面です）。<br />
　ここでは4つのオブジェクト（球体2つとボックス2つ）がお互いに反発しあいながら運動を繰り返してます。<br />
<p>&nbsp;</p>
<img src="img/0005a.jpg" width="80%"/>
<p>図0005a</p>
<p>&nbsp;</p>
　今回作成するクラスは、<b>MoveObjectクラス</b>です。<b>Character.hとCharacter.cpp</b>に記述があります。<br/>
<br />
<h4>Rigidbodyコンポーネント</h4>
　衝突判定に自動反発をつけるためには<b>Rigidbodyコンポーネント</b>を使用します。<br />
　まず<b>Character.h</b>に<b>MoveObjectクラス</b>の宣言を記述します。今回のオブジェクトは作成方法も前項とは違いますので、注意しましょう。
<br />
<div class="box1">
<pre>
    //--------------------------------------------------------------------------------------
    //  class MoveObject : public GameObject;
    //  用途: 動くオブジェクト
    //--------------------------------------------------------------------------------------
    class MoveObject : public GameObject{
    public:
        //構築と破棄
        MoveObject(const shared_ptr&lt;Stage>& StagePtr);
        virtual ~MoveObject();
        virtual void OnCreate() override{}
        //初期化
        void OnCreateWithParam(const Vector3& StartPos, 
            const Vector3& StartVelocity, bool Type);
        //ターンの最終更新時
        virtual void OnLastUpdate() override;
    };
</pre>
</div>
　今回は、コンストラクタの引数は<b>const shared_ptr&lt;Stage>& StagePtr</b>のみあります。その代り
<div class="box1">
<pre>
        //初期化
        void OnCreateWithParam(const Vector3& StartPos, 
            const Vector3& StartVelocity, bool Type);
</pre>
</div>
　という関数（<b>仮想関数ではない</b>）が実装されています。また、<b>OnCreate()仮想関数</b>は存在しますが、中身は空です。<br/>
　更新処理は、void OnLastUpdate()仮想関数</b>を多重定義して実装します。<br />
<br />
　配置されるのは<b>MoveObjectクラス</b>ですが、球体もボックスも同じクラスを使います。球体かボックスかを区別つけるために、コンストラクタに<b>bool Type</b>という引数を設けます。<b>true</b>なら球体、<b>false</b>ならボックスです。<br />
　以下が、<b>Character.cpp</b>にある<b>void MoveObject::OnCreateWithParam()関数</b>の実体です。
<div class="box1">
<pre>
    //初期化
    void MoveObject::OnCreateWithParam(const Vector3& StartPos, 
        const Vector3& StartVelocity, bool Type){

        auto PtrTransform = AddComponent&lt;Transform>();
        PtrTransform->SetScale(1.0f, 1.0f, 1.0f);
        PtrTransform->SetRotation(0.0f, 0.0f, 0.0f);
        PtrTransform->SetPosition(StartPos);
        <span class="red">if (Type){
            //Sphereの衝突判定をつける
            auto PtrSphere = AddComponent&lt;CollisionSphere>();
        }
        else{
            //OBBの衝突判定をつける
            auto PtrObb = AddComponent&lt;CollisionObb>();
        }</span>
        //物理計算をつける
        <span class="red">auto PtrRigit = AddComponent&lt;Rigidbody>();
        PtrRigit->SetVelocity(StartVelocity);</span>
        //影をつける
        auto ShadowPtr = AddComponent&lt;Shadowmap>();
        if (Type){
            ShadowPtr->SetMeshResource(L"DEFAULT_SPHERE");
        }
        else{
            ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");
        }
        //描画コンポーネント
        auto PtrDraw = AddComponent&lt;PNTStaticDraw>();
        if (Type){
            PtrDraw->SetMeshResource(L"DEFAULT_SPHERE");
        }
        else{
            PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
        }
        PtrDraw->SetTextureResource(L"TRACE_TX");
        //透明有効
        SetAlphaActive(true);
    }
</pre>
</div>
　赤くなっているところがポイントです。衝突判定は、形状が違いますので、球体とボックスで、追加するコンポーネントを変えています。<br />
<div class="box1">
<pre>
        //物理計算をつける
        <span class="red">auto PtrRigit = AddComponent&lt;Rigidbody>();
        PtrRigit->SetVelocity(StartVelocity);</span>
</pre>
</div>
　また、上記2行で自動反発するようになります。<br />
　<b>Rigidbodyコンポーネント</b>を追加した場合は、<b>TransformコンポーネントのPosition</b>は通常は直接変更しません。（回転は変更することがあります）<br />
　これは大変重要なことです。<b>Rigidbodyコンポーネント</b>は内部に、速度、反発係数や質量を持っていて、衝突相手の質量や速度を加味しながら、自身の反発方向と速度を計算します。<br />
　<b>Rigidbodyコンポーネント</b>を追加した場合、変更するのは<b>速度</b>です。ここでは、スタート時の初速度のみ設定しています。<br />
　<b>PtrRigit->SetVelocity(StartVelocity);</b>が初速度を設定する設定です。<br/>
<br />
　続いて、<b>OnLastUpdate()関数</b>です。
<div class="box1">
<pre>
    //更新
    void MoveObject::OnLastUpdate(){
        auto PtrRigit = GetComponent&lt;Rigidbody>();
        auto Velo = PtrRigit->GetVelocity();
        //自動反発で速度yが０以外になる場合があるので調整
        Velo.y = 0;
        PtrRigit->SetVelocity(Velo);
    }
</pre>
</div>
　ここでは、自動反発によって速度のY値がずれる可能性があるので調整しています。つまり、反発は3次元方向に向かうので、平面上でまっすぐ衝突しても、浮動小数点演算の関係で、若干誤差が出てしまいます。それを調整します。<br />
　ポイントは、ここでも<b>TransformコンポーネントのPosition</b>を修正するのではなく、<b>RigidbodyコンポーネントのVelocity（速度）</b>を変更しているところです。<br />
<br />
<h4>障害物</h4>
　ここで配置される障害物は<b>FixedBoxクラス</b>です。初期化時に、<b>大きさ、回転、位置</b>を設定構築する単純なクラスです。<br />
　<b>FixedBoxクラス</b>にも<b>衝突判定コンポーネントとRigidbodyコンポーネント</b>を追加します。<br />
　以下は、<b>void FixedBox::Create()関数</b>です。
<div class="box1">
<pre>
    //初期化
    void FixedBox::OnCreateWithParam(const Vector3& Scale,
        const Vector3& Rotation,const Vector3& Position){

        auto PtrTransform = AddComponent&lt;Transform>();
        PtrTransform->SetScale(Scale);
        PtrTransform->SetRotation(Rotation);
        PtrTransform->SetPosition(Position);

        auto PtrRegid = AddComponent&lt;Rigidbody>();
        auto PtrObb = AddComponent&lt;CollisionObb>();
        <span class="red">PtrObb->SetFixed(true);</span>

        //影をつける
        auto ShadowPtr = AddComponent&lt;Shadowmap>();
        ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");

        auto PtrDraw = AddComponent&lt;PNTStaticDraw>();
        PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
        PtrDraw->SetTextureResource(L"WALL_TX");
        PtrDraw->SetOwnShadowActive(true);
    }
</pre>
</div>
　衝突判定コンポーネントの設定で
<div class="box1">
<pre>
        <span class="red">PtrObb->SetFixed(true);</span>
</pre>
</div>
　と記述しています。この設定で、それ自身は反発して移動したりしません。<br />
　SetFixedをtrueに設定すると<b>移動できない</b>というわけではありません。<b>他のオブジェクトの影響を受けない（つまりそれ自身は自動反発などの事後処理をしない）</b>という意味です。<br />
<br />
<h4>ゲームステージ</h4>
　<b>GameStage.cpp</b>では、上記2つのクラスを配置しています。この項では<b>AddGameObjectテンプレート関数</b>ではなく<b>AddGameObjectWithParamテンプレート関数</b>を利用します。こうすると、構築したオブジェクトの<b>OnCreateWithParam()</b>を呼び出して、そのパラメータとして、ステージのポインタのあとのパラメータを渡します。
<div class="box1">
<pre>
    //固定のボックスの作成
    void GameStage::CreateFixedBox(){
        //配列の初期化
        vector&lt; vector&lt;Vector3> > Vec = {
            {
                Vector3(20.0f, 1.0f, 1.0f),
                Vector3(0.0f, 0.0f, 0.0f),
                Vector3(0.0f, 0.5f, 10.0f)
            },
            {
                Vector3(20.0f, 1.0f, 1.0f),
                Vector3(0.0f, 0.0f, 0.0f),
                Vector3(0.0f, 0.5f, -10.0f)
            },

            {
                Vector3(1.0f, 1.0f, 20.0f),
                Vector3(0, 0, 0),
                Vector3(10.0f, 0.5f, 0.0f)
            },
            {
                Vector3(1.0f, 1.0f, 20.0f),
                Vector3(0, 0, 0),
                Vector3(-10.0f, 0.5f, 0.0f)
            },
        };
        //オブジェクトの作成
        for (auto v : Vec){
            <span class="red">AddGameObjectWithParam&lt;FixedBox>(v[0], v[1], v[2]);</span>
        }
    }

    //動くオブジェクトの作成
    void GameStage::CreateMoveObject(){
        <span class="red">AddGameObjectWithParam&lt;MoveObject>(Vector3(-8.0f, 0.5, 0), 
            Vector3(7.0f, 0.0, 7.0f), true);
        AddGameObjectWithParam&lt;MoveObject>(Vector3(0.0f, 0.5, 0), 
            Vector3(-5.0f, 0.0, 6.0f), false);
        AddGameObjectWithParam&lt;MoveObject>(Vector3(8.0f, 0.5, 0), 
            Vector3(-7.0f, 0.0, 6.0f), true);
        AddGameObjectWithParam&lt;MoveObject>(Vector3(0.0f, 0.5, 2.0f), 
            Vector3(6.0f, 0.0, 5.0f), false);</span>
    }
    //初期化
    void GameStage::OnCreate(){
        try{
            //リソースの作成
            CreateResourses();
            //ビュー類を作成する
            CreateViews();
            //プレートを作成する
            CreatePlate();
            <span class="red">//固定ボックスの作成
            CreateFixedBox();
            //動くオブジェクトの作成
            CreateMoveObject();</span>
        }
        catch (...){
            throw;
        }
    }
</pre>
</div>
　<b>GameStage::Create()関数</b>で、構築する関数を呼ばないといけません。この記述は、結構忘れがちです。<br/>
　また、なぜ、<b>AddGameObjectWithParam()やOnCreateWithParam()</b>のような関数があるのでしょうか？<br />
　それは、今回構築したオブジェクトの初期値を考えてみてください。今回設定する、スケーリング、回転、位置情報は、あくまで<b>初期値</b>となっています。その値は、最初に設定したらゲームを終了するまで参照することはありません。<br />
　そのために前項のように、メンバ変数として初期値を持っておくのは無駄です。<br />
　のちほど再利用する場合以外は、このようにゲームオブジェクトを構築する方法があるという紹介でした。
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_04.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_06.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
