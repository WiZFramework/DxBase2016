<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2016ドキュメント(2016年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>６．行列の直接操作</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>６０２．衝突判定におけるトンネル現象の回避</h3>
<br />
　前項では、<b>コア衝突判定関数呼び出し</b>の問題点について触れました。<br />
　この項では、その回避方法について考えます。まず、以下の図を見てください。この図は、<b>オブジェクトの移動</b>を図解したものです。
<p>&nbsp;</p>
<img src="img/6002a.jpg" width="80%"/>
<p>図6002a</p>
<p>&nbsp;</p>
　これを、<b>移動</b>とは考えずに、<b>移動範囲を全て網羅する境界ボリューム</b>と考えたらどうなるでしょう？<br />
　その観念図が以下になります。
<p>&nbsp;</p>
<img src="img/6002b.jpg" width="80%"/>
<p>図6002b</p>
<p>&nbsp;</p>
　ブルーの球体が<b>移動範囲を全て網羅する境界ボリューム</b>です。このブルーの球体とボックスの衝突がなければ<b>移動中の衝突はない</b>ということになります。<br />
　では衝突した場合はどうなるでしょう。以下のような状態になります。
<p>&nbsp;</p>
<img src="img/6002c.jpg" width="80%"/>
<p>図6002c</p>
<p>&nbsp;</p>
　移動距離を直径としたボリューム境界を作成することで、前回のターンから今回のターンの間のどのタイミングかで衝突しているのがわかります。では、<b>どのタイミングで（例えば、0.005秒後など）衝突したか</b>を得ることはできないでしょうか？<br />
　その計算方法を表したのが下の図です。いらない床などは外してます。
<p>&nbsp;</p>
<img src="img/6002d.jpg" width="80%"/>
<p>図6002d</p>
<p>&nbsp;</p>
　この図では、まず、1ターン分の移動距離を直径とした球体を作成し、それとOBBの判定を行います。ここで衝突してなければ判定は終了です。衝突していれば、いまの球体を<b>前半分と後半分を直径とした球体に分け</b>それぞれ判定します。もし後ろ半分で衝突していれば、<b>さらに半分に分けて衝突判定</b>します。<br />
　このように、球体を小分けにしていって限界までに球体が小さくなったとき、が<b>衝突した瞬間（正確には衝突する直前）</b>、ということになります。これを再帰的に検証します。<br />
　1ターンの移動距離を直径とした球体、をもとに小分けにするので、最終的な小さな球体の位置は、前回のターンから衝突までの時間、を出すことができます。<br />
　それを実装したのが<b>サンプル602</b>です。実行するの以下のような画面が出てきます。前項ではトンネル現象を起こしていた衝突が、突き抜けずに衝突しているのがわかります。
<p>&nbsp;</p>
<img src="img/6002e.jpg" width="80%"/>
<p>図6002e</p>
<p>&nbsp;</p>
　ここで上記の再帰処理している関数が、<b>MoveSphere::RecTestSphereObb()関数</b>です。
<div class="box1">
<pre>
    bool MoveSphere::RecTestSphereObb(const SPHERE& SrcSp, const Vector3& SrcVelocity,
        const OBB& DestObb,
        float StartTime, float EndTime, float& HitTime){
        const float EPSILON = 0.002f;
        SPHERE SrcSp2;
        float mid = (StartTime + EndTime) * 0.5f;
        SrcSp2.m_Center = SrcSp.m_Center + SrcVelocity * mid;
        SrcSp2.m_Radius = (mid - StartTime) * SrcVelocity.Length() + SrcSp.m_Radius;
        Vector3 RetVec;
        if (!HitTest::SPHERE_OBB(SrcSp2, DestObb, RetVec)){
            return false;
        }
        if (EndTime - StartTime &lt; EPSILON){
            HitTime = StartTime;
            return true;
        }
        if (RecTestSphereObb(SrcSp, SrcVelocity, DestObb, StartTime, mid, HitTime)){
            return true;
        }
        return RecTestSphereObb(SrcSp, SrcVelocity, DestObb, mid, EndTime, HitTime);
    }
</pre>
</div>
　この関数は、ライブラリ中<b>TransHelper.h</b>にある<b>HitTest::CollisionTestSphereObb()関数</b>と同様のものです。これを、実際に移動する前に呼び出しています。<br />
　この関数は、衝突していたら、衝突時の、衝突時間を<b>HitTime</b>に返します。ですので呼び出し側では、その時間分だけオブジェクトを移動させてそこでそのターンの移動とします。厳密にいえば、システムは約60分の1秒経っているのに、移動物はそれ未満分しか移動してない（衝突時までにか移動しない）のですが、ゲーム上ではあまり違和感はないはずです。トンネル現象よりはよほどましな動きになります。<br />
　この関数の呼び出し方は以下の形です。<b>移動させる前</b>に呼び出しているところがポイントです。<br />
<div class="box1">
<pre>
    void MoveSphere::OnUpdate(){
        //行き過ぎた場合の対応
        if (m_Posision.x > m_StartPosision.x){
            m_Posision = m_StartPosision;
            //速度を速くする
            m_Velocity.x = <span class="red">-50.0f;</span>
        }
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        //Boxを取得
        auto BoxPtr = GetStage()->GetSharedGameObject&lt;Box>(L"Box");
        auto BoxMat = BoxPtr->GetComponent&lt;TransformMatrix>()->GetWorldMatrix();
        OBB BoxObb(Vector3(1.0f, 1.0f, 1.0f), BoxMat);
        SPHERE Sp(m_Posision, m_Scale.x / 2.0f);
        float HitTime;
        bool Hit = false;
        //衝突判定
        //実際に動かす前に判定する
        if (<span class="red">RecTestSphereObb(Sp, m_Velocity, BoxObb, 0, ElapsedTime, HitTime)</span>){
            //衝突した
            ElapsedTime = HitTime;
            Hit = true;
        }
        //判定後に動かす
        auto Span = m_Velocity * ElapsedTime;
        m_Posision += Span;
        if (Hit){
            //衝突してたら反転移動（ゆっくり）
            m_Velocity.x = 1.0f;
        }
        auto PtrTransformMatrix = GetComponent&lt;TransformMatrix>();
        Matrix4X4 mat;
        mat.DefTransformation(
            m_Scale,
            Vector3(0.0f, 0.0f, 0.0f),
            m_Posision
            );
        PtrTransformMatrix->SetWorldMatrix(mat);
    }
</pre>
</div>
<br />
　また、この関数は<b>OBBは動いてない</b>ものとして扱います。OBBも動いている場合は、OBBの移動分を、球体の移動に加算することで同じ結果を得られます。たとえば、時速20キロ出ている物体同士が、正面衝突したら、片方が止まっていて、片方が40キロ出ているのと同じことです。<b>MoveSphere::RecTestSphereObb()関数</b>が返すのは、あくまで<b>衝突した時間</b>です。ですから、片方を制止させて計算しても同じ結果になります。<br/>
　この再帰関数同様の関数が、ライブラリ中<b>TransHelper.h</b>の<b>HitTest構造体内</b>にあります。OBBとOBBのもの、カプセルとOBBのもの、カプセル同士のものなどもありますので確認してください。


<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="60_01.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
