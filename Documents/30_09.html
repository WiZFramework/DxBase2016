<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2016ドキュメント(2016年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>３．演出補助</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<br/>
<h3>３０９．モデルのアニメーション</h3>
<br />
<h4>ボーンアニメーション</h4>
　前項で紹介したように、<b>DxBase2016フレームワーク</b>では、モデルの形式を<b>独自フォーマット</b>であつかいます。<br />　この形式は、<b>.bmf</b>という拡張子を持ち、<b>Autodesk社のFBXフォーマト</b>を<b>データ変換ツール(Fbx2Bin)</b>により変換して使用します。<br />
　前項では<b>アニメーションしない（つまりスタティックな）</b>メッシュの描画を紹介しました。<br />
　この項では、<b>アニメーションをする</b>モデルを扱います。これをフレームワークでは<b>ボーンモデル</b>と称します。<br />　<b>ボーン</b>というのは、直訳すると<b>骨</b>という意味です。モデルデータの中に<b>骨の情報</b>を含めます。データ形式は<b>行列</b>です。つまり前項で紹介したような<b>Tポーズ</b>の状態から、<b>ローカル変換するための行列情報</b>を含めるのです。これが<b>ボーン情報（行列）</b>です。<br />
　<b>ボーン情報（行列）</b>は一つのモデルに対して複数作成します。たとえばこの項で紹介するモデルは<b>22個の</b>ボーンを持っています。<br />
<br />
　さて、これらボーンに対して、各頂点はどのように影響するのでしょうか。<br />
　各頂点には、<b>その頂点に影響を与えるボーン</b>を4つ選択します。この<b>4つ</b>という値は固定です。フレームワークやエンジンによってはもっと少ない場合もあります。<b>DxBase2016フレームワーク</b>では<b>4つ</b>という意味です。<br />
　各頂点は、その頂点に影響を与えるボーンと、その影響具合（これを<b>ウエイト</b>といいます）を頂点データに持ちます。<br />
　ボーンと各頂点の関係を考えるのに、<b>人間（動物）の関節と皮膚</b>について考えてみましょう。<b>ボーン</b>は<b>関節</b>です。皮膚の表面に、頂点があるとしましょう。この頂点は、近くの関節が動くと、一緒にその関節に影響されて伸び縮みします。実際には頂点が伸び縮みするのではなく、関節に引っ張られるような形でついていく感じです。しかし、関節は一つではないので複数の関節の影響を受けます。例えば肘に近い部分の頂点は、ほぼ、肘の影響しか受けません。しかし、肘と手首の中間にある頂点は、肘と手首の両方から影響を受けます。このように頂点によって、関節に影響をうける割合が違うのがわかります。<br />
　この割合が<b>ウェイト</b>です。ある頂点が、関節１に30パーセント、関節2に50パーセント、関節3に20パーセント、関節4には0パーセント、という感じで設定します。<br />
　このように設定しておくと、ボーンが移動したときに、各頂点もそれにつられて移動しますが、影響する割合によって、移動する場所が変化します。この処理を、モデルが持つすべての頂点に行うと、滑らかな動きを演出できるのです。この処理を<b>スキン処理</b>といいます。そしてスキン処理をするメッシュを<b>スキンメッシュ</b>といいます。<b>スキンメッシュ</b>は上記の<b>ボーンモデル</b>と同じ意味です。<b>スキンメッシュ</b>といういい方のほうが一般的です。（なぜ言い方を変えたかというと、データ的には前項の<b>スタティック</b>に対して、<b>ボーンデータが入っている</b>という違いを強調するためです。<b>スキン</b>という意味合いは、データ形式ではなく、<b>処理方法</b>のことなので、違う名称にしました）。<br />
　このようにして、各瞬間瞬間のボーン行列を変化させることにより、<b>アニメーション</b>を実装しています。<br />
<br />
<h4>アニメーションの2つの方法</h4>
　さて、各ボーン行列を変化させて行うアニメーションですが、その変化方法に２つの方法があります。<br />
　<b>階層化方式と直接方式</b>です。この違いを理解するのに、動物の体を考えてみましょう。<br />
　動物の体は、骨と関節が組み合わさって、柱を形成しています。例えば、腰の骨を中心と考えると、そこから背骨、首、肩、ひじ、手首、というように、腰の骨から手首に至るまで、階層的に並んでいます。これを親子関係でいうなら、腰が動けばその子供や孫にあたる関節や首が一緒に影響されますが、肘が動くだけなら、手首にしか影響をあたえません。<br />
　これらの関係を<b>階層的にデータとして持つ</b>方法があります。つまり親子の関係を定義し、子は親からの相対行列のみを持つという考え方です。これが<b>階層化方式</b>です。<br />
　これに対して、<b>直接方式</b>は、各ボーンを、<b>中心（例えば腰）</b>からの直接的な相対行列によって管理します。<br />
　なので、各ボーン行列には、お互い何の関連性もありません。極端な話、肩のボーンが動くだけなら、スキン化されている頂点は引っ張られますが、ひじや手首が一緒に動くことはありません。<br />
　この2つの方式には利点と欠点があります。<br />
　<b>階層化方式</b>は、データは複雑ですが、例えば３Ｄソフトが書きだすデータ内に親子関係が記されているので、例えば腕を振るスピードや角度を微調整しようといった場合に、ちょっとした修正なら３Ｄソフトに戻らなくても修正可能です。しかし、<b>直接方式</b>は、階層化情報は３Ｄソフト内にはありますが、再生する側（つまりゲーム側）にはその情報を持たないので、ちょっとした修正も３Ｄモデルまで戻らなければいけません。<br />
<br />
　<b>データ変換ツール(Fbx2Bin)</b>の作成するデータは<b>直接方式</b>を採用しています。そのほうがデータ書き出しが単純なのと、<b>FBX_SDK</b>の仕様が複雑なため（たとえばボーン階層を複数持てるなど）、それを解析するメリットがあまりないからです。もちろん<b>データ変換ツール(Fbx2Bin)</b>を修正して<b>階層化方式</b>にすることは可能です。（かなり勉強になること請け合いです）。<br />
　ちなみに<b>階層化方式</b>を取っていたデータは、たとえばマイクロソフト社の<b>Xファイル形式</b>があります。DirectX9のころはこのファイル形式にDirectX自体が対応していて、また<b>Xファイル形式</b>で書き出せる３Ｄソフトも多かったのですが、DirextX11で完全に<b>Xファイル形式</b>に対応しなくなったために、現在では３Ｄソフト側でも<b>Xファイル形式</b>で書き出せるものは少なくなりました。<br />
<br />
<h4>Fbx2Binの書き出すデータ</h4>
　さて、<b>データ変換ツール(Fbx2Bin)</b>の書き出すデータについて若干説明します。（詳しくはFbx2Binの解説を参照ください）。<br />
　Fbx2Binのアニメーションは<b>サンプル</b>という単位で扱います。FBX_SDKは複数の<b>アニメーションライン</b>を作成できますが、Fbx2Binで読み取れる<b>アニメーションライン</b>は一つです。<br/>
　<b>アニメーションライン</b>というのは、１つのアニメーションを定義するデータです。３Ｄソフトは複数作成できます。たとえば<b>歩く、走る、待機</b>などのアニメーションを別々に作成できます。<br />
　しかしFbx2Binで読めるようにするためには、これらのアニメーションを、<b>１つのアニメーションライン</b>にまとめて作成する必要があります。（これは通常グラフィッカーの仕事です）。たとえば、0秒目から3秒までは<b待機</b>、3秒から10秒までは<b>歩き</b>のように、複数のアニメーションを、１つのラインにまとめます。そしてその情報をプログラマに伝えます。<br />
　Fbx2Binは、そのようにして作成されたFBXファイルを、<b>実際に再生しながら</b>その瞬間瞬間のボーン行列を<b>サンプリング（抽出）</b>します。たとえば、サンプル単位が１秒間に10個と指定して保存すると、１秒間に１０セットのボーン行列の配列が保存されます。<br />
　このことからわかるように、データを書き出す側でこのサンプル単位を細かくすると、より、FBXデータに合ったデータが作成できるのがわかります。しかし細かくすればいいというものではなくて、たとえばサンプル単位を60にすると、ボーン数が22ですから、1秒間に1320個の行列ができます。これではデータ的にも重くなりすぎます。<br />
<br />
<h4>.bmfデータの再生</h4>
　このようにしてFbx2Binによって作成されたデータ<b>.bmfデータ</b>を再生する側（ゲーム側）では、サンプル情報をアニメーションの<b>キーフレーム</b>として扱います。<br />
　<b>キーフレーム</b>というのは基準の行列です。たとえば、10番目のサンプル行列と11番目のサンプル行列のあいだを変化させる場合、10番目のサンプル行列とぴったりしたタイミングであればその行列を、11番目のサンプル行列とぴったりしたタイミングであればその行列で描画するわけですが、その間は10番目と11番目の行列間を<b>補完処理</b>をして求めます。この処理により滑らかな動きを再生しようと試みます。<br />
　このように補完計算するためにサンプル間隔が荒いと、すごく離れた行列同士の補完ということになり、実際にFBXの時のアニメーションとは全く別のアニメーションになってしまう危険があります。ですので、Fbx2Binでのサンプル間隔は<b>荒すぎず、細かすぎず</b>という、まあまあの再生ができる間隔にする必要があります。<br />
<br />
<h4>ボーンモデルの表示</h4>
　さて、ここまで簡単にFbx2Binのデータについて説明してきましたが、実際のゲームへの実装は、描画コンポーネントを使って行います。<br />
　<b>Sample309ディレクトリ</b>のソリューションを開いて、リビルド、実行してみましょう。すると以下の画面が現れます。
<p>&nbsp;</p>
<img src="img/3009a.jpg" width="80%"/>
<p>図3009a</p>
<p>&nbsp;</p>
　ここでは前項で<b>Tポーズ</b>だったモデルが、アニメーションしながら移動します。Aボタンでジャンプすると再生されるアニメーションが変わります。<br />
　ここでの記述は、まず前項同様、<b>GameStage::CreateResourses()関数</b>で<b>リソースの登録</b>から始まります。<br />
<div class="box1">
<pre>
    void GameStage::CreateResourses(){
        //中略
        App::GetApp()->RegisterBoneModelMesh(L"Chara_R_MESH", 
            App::GetApp()->m_wstrRelativeDataPath, L"Chara_R.bmf");
    }
</pre>
</div>
　<b>App::GetApp()->RegisterBoneModelMesh()関数</b>は、指定された<b>.bmfファイル</b>を<b>ボーンモデル</b>として読み込みます。ボーン情報やスキン情報が入ってなければ例外が発生します。<br />
　ここでうまく読み込むことができたら、あとはプレイヤーでそのリソースを使用できます。<br />
　以下は<b>Player::OnCreate()関数</b>です。
<div class="box1">
<pre>
    void Player::OnCreate(){
        //中略

        Matrix4X4 SpanMat; // モデルとトランスフォームの間の差分行列
        SpanMat.DefTransformation(
            Vector3(1.0f, 1.0f, 1.0f),
            Vector3(0.0f, XM_PI, 0.0f),
            Vector3(0.0f, -0.5f, 0.0f)
            );

        //影をつける（シャドウマップを描画する）
        auto ShadowPtr = AddComponent&lt;Shadowmap>();
        //影の形（メッシュ）を設定
        ShadowPtr->SetMeshResource(L"Chara_R_MESH");
        ShadowPtr->SetMeshToTransformMatrix(SpanMat);

        //描画コンポーネントの設定
        <span class="red">auto PtrDraw = AddComponent&lt;PNTBoneModelDraw>();</span>
        //描画するメッシュを設定
        PtrDraw->SetMeshResource(L"Chara_R_MESH");
        PtrDraw->SetMeshToTransformMatrix(SpanMat);
        <span class="red">PtrDraw->AddAnimation(L"Default", 60, 20, true, 20.0f);
        PtrDraw->AddAnimation(L"Hit", 30, 30, false, 30.0f);
        PtrDraw->ChangeCurrentAnimation(L"Default");</span>

        //透明処理
        SetAlphaActive(true);

        //中略
    }
</pre>
</div>
　赤くなっているのが重要なところです。まず
<div class="box1">
<pre>
        //描画コンポーネントの設定
        <span class="red">auto PtrDraw = AddComponent&lt;PNTBoneModelDraw>();</span>
</pre>
</div>
　で、描画コンポーネントを<b>PNTBoneModelDraw</b>にします。このコンポーネントはボーンモデル専用の描画コンポネントです。続いて、メッシュを設定して
<div class="box1">
<pre>
        <span class="red">PtrDraw->AddAnimation(L"Default", 60, 20, true, 20.0f);
        PtrDraw->AddAnimation(L"Hit", 30, 30, false, 30.0f);
        PtrDraw->ChangeCurrentAnimation(L"Default");</span>
</pre>
</div>
　のようにアニメーションを定義、そして、最初のアニメーションを設定します。<br/>
　<b>PtrDraw->AddAnimation()関数の引数</b>は
<div class="box1">
<pre>
    void AddAnimation(const wstring& Name, int StartSample, int SampleLength, bool Loop,
            float SamplesParSecond = 30.0f);
</pre>
</div>
　のようになっています。<b>Name</b>はアニメーション名です。アニメーションを切り替えたりするのに、この名前を使います。<br />
　<b>StartSampleとSampleLength</b>は<b>int</b>を指定します。開始サンプルと、サンプルの長さ（終了サンプルではないので注意！）です。マイナスの値は設定できません（例外が出ます）。<br />
　<b>Loop</b>は、ループするかどうか、です。ループする場合はtrueにします。<br />
　最後の<b>SamplesParSecond</b>は、秒あたりのサンプル数です。floatです。これも0.0f以下は指定できません。この値が大きくなると再生スピードが速くなります。1秒間にこなすサンプル数なので、たとえば1秒間に20こなすのと30こなすのでは、後者が速くなりますね。<br />
　ここでは２つのアニメーションを定義しています。<b>L"Default"とL"Hit"</b>です。前者は通常移動中のアニメーションです。こちらはループします。<br />
　後者はジャンプした時に銃を構えるアニメーションです。こちらはスピードを少し速くしています。またループしません。<br />
　このようにアニメーションを定義し、<b>PtrDraw->ChangeCurrentAnimation()</b>で最初のアニメーションを設定しています。<br />
<br />
<h4>アニメーションの更新と変更</h4>
　<b>アニメーションの更新（アニメの進行）</b>は自動で行われないので、OnUpdate()関数などに記述する必要があります。
<div class="box1">
<pre>
    void Player::OnUpdate(){
        //中略

        //アニメーションを更新する
        auto PtrDraw = GetComponent&lt;PNTBoneModelDraw>();
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        <span class="red">if (PtrDraw->UpdateAnimation(ElapsedTime) &&
            PtrDraw->GetCurrentAnimation() == L"Hit"){
            PtrDraw->ChangeCurrentAnimation(L"Default");
        }</span>
    }
</pre>
</div>
　描画コンポーネントの<b>UpdateAnimation()関数</b>には前ターンからの経過時間を設定します。<br />
　また、<b>UpdateAnimation()関数</b>の戻り値は<b>そのアニメーションがループしない場合、アニメーションが終了したらtrueを返す</b>という処理になっています。ですから、アニメーションが<b>L"Hit"</b>であった場合、<b>L"Hit"</b>が終了した場合に<b>true</b>が返ります。<br />
　なお、このサンプルではループしないアニメーションは、<b>L"Hit"</b>だけなので、if文内の、<b>PtrDraw->GetCurrentAnimation() == L"Hit"</b>のチェックは必要ないのですが、今後いくつものアニメーションを登録した場合、現在のアニメーションの特定が必要になる場合がありますので、記述しておきました。<br/>
　また、ここでは、Player::OnUpdate()にアニメーションの更新を直接書いていますが、せっかくステートマシンを使用しているので、ふるまい関数（モーション関数）などに記述するほうが、より、いいソースなのは言うまでもありません。<br />
<br/>
　ここで、アニメチェンジの対象となる<b>L"Hit"</b>ですが、開始は、ジャンプしたタイミングになります。以下がその記述です。<br />
<div class="box1">
<pre>
    void Player::JumpMotion(){
        //中略
        //アニメーションを変更する
        auto PtrDraw = GetComponent&lt;PNTBoneModelDraw>();
        <span class="red">PtrDraw->ChangeCurrentAnimation(L"Hit");</span>
    }
</pre>
</div>
　このアニメーション<b>L"Hit"</b>は、ループしません。ですので、アニメが終わると、<b>Player::OnUpdate()関数</b>で呼び出している<b>PtrDraw->UpdateAnimation()関数</b>が<b>true</b>を返すので、<b>L"Default"</b>に戻すことができます。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="30_08.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="30_11.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
