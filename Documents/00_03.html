<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="css/main.css" rel="stylesheet" type="text/css">
<title>DxBase2016ドキュメント(2016年)</title>
</head>
<body>
<!-- 全体コンテナ　-->
<div id="container">
<div id="header">
<h2>０．チュートリアル</h2>
</div>
<!-- コンテンツ　-->
<div id="contents">
<h3>００３．オブジェクトを動かす</h3>
<br />
<h4>Transformコンポーネントによる移動</h4>
　前項では、<b>TransformMatrixコンポーネント</b>に直接ワールド行列を設定して、オブジェクトのスケーリングや回転、位置を決定していました。<br />
　しかし行列を直接操作するのは、慣れが必要です。そこでフレームワークでは、<b>スケーリング、回転、位置を設定すれば</b>ワールド行列を作成してくれるコンポーネントがあります。<b>Transformコンポーネント</b>がそれで、<b>TransformMatrixコンポーネントの派生クラス</b>として実装されています。<br />
　<b>Tutorial003ディレクトリ</b>内のソリューション<b>DxBase2016.sln</b>を<b>VisualStdio2013</b>で開くと以下のような実行画面が出てきて、ボックスが左右に移動します。
<p>&nbsp;</p>
<img src="img/0003a.jpg" width="80%"/>
<p>図0003a</p>
<p>&nbsp;</p>
　これは、配置オブジェクトの<b>TransformコンポーネントのPosition</b>を変化させて実装しています。<br /
><br />
　ボックスを作成するには、前項のように、<b>Character.h、Character.cpp</b>に、<b>Boxクラス</b>を記述して、<b>GameStage.h、GameStage.cpp</b>で、<b>AddGameObjec()テンプレート関数</b>を呼び出します。ここまでは同じです。<br />
　<b>Transformコンポーネント</b>を実装するには、<b>OnCreate()関数</b>内で、以下のように記述します。以下は、<b>Character.cpp</b>に記述された、<b>BoxクラスのOnCreate()関数の実体</b>です。
<div class="box1">
<pre>
    //初期化
    void Box::OnCreate(){
        auto PtrTransform = AddComponent&lt;Transform>();
        PtrTransform->SetScale(1.0f, 1.0f, 1.0f);
        PtrTransform->SetRotation(0.0f, 0.0f, 0.0f);
        PtrTransform->SetPosition(m_StartPos);
        //影をつける
        auto ShadowPtr = AddComponent&lt;Shadowmap>();
        ShadowPtr->SetMeshResource(L"DEFAULT_CUBE");
        auto PtrDraw = AddComponent&lt;PNTStaticDraw>();
        PtrDraw->SetMeshResource(L"DEFAULT_CUBE");
        PtrDraw->SetTextureResource(L"TRACE_TX");
        //透明処理
        SetAlphaActive(true);
    }
</pre>
</div>
　このように、行列は一切記述してないのがわかります。<b>Transformコンポーネント</b>は、<b>TransformMatrixコンポーネント</b>と違い、自動的に設定されません。そのため
<div class="box1">
<pre>
        auto PtrTransform = AddComponent&lt;Transform>();
</pre>
</div>
　のように、<b>AddComponentテンプレート関数</b>を使って実装します。ここで注意したいのは、<b>Transformコンポーネント</b>を実装すると、これまでの<b>TransformMatrixコンポーネント</b>は使用できなくなることです。<b>TransformMatrixコンポーネント</b>の実装は、<b>TransformMatrixコンポーネント</b>のバージョンアップと考えることができます。<br />
<br />
<h4>OnUpdate()仮想関数</h4>
　配置されたオブジェクトを変化させるには<b>OnUpdate()仮想関数を多重定義（オーバーライド）</b>します。<br />
　以下は、<b>Character.h</b>に記述された、<b>BoxクラスのOnUpdate()関数の宣言</b>です。
<div class="box1">
<pre>
        //更新
        virtual void OnUpdate() override;
</pre>
</div>
　仮想関数のオーバーライドをあらわす<b>override</b>は、C++11になって出てきた文法です。間違った多重定義があった場合、コンパイラがエラーにしてくれますので、つけるようにしましょう。<br />
　そして、以下は、<b>BoxクラスのOnUpdate()関数の実体</b>です。<b>Character.cpp</b>に記述されています。<div class="box1">
<pre>
    //更新
    void Box::OnUpdate(){
        //前回のターンからの経過時間を求める
        float ElapsedTime = App::GetApp()->GetElapsedTime();
        auto PtrTransform = GetComponent&lt;Transform>();
        //位置の取得
        auto Pos = PtrTransform->GetPosition();
        //値を変化させる
        Pos.x += m_Span * ElapsedTime;
        if (abs(Pos.x) > 3.0f){
            //もし左右3.0を超えたら反転
            m_Span *= -1.0f;
        }
        //新しい位置を設定
        PtrTransform->SetPosition(Pos);
    }
</pre>
</div>
　<b>OnUpdate()仮想関数</b>は、<b>ターン</b>のたびに呼ばれます。<b>ターン</b>というのは、おおむね60分の1秒に1度呼ばれる、処理のタイミングです。<br />
　ほとんどのゲームソフトは、<b>無限ループで動作</b>し続けていて、その間に更新処理や描画処理を行います。ですからゲームのプログラミングの大きなウェイトはその<b>ターン毎の処理を記述する</b>ということです。<br />
　アニメーションは、映画の1コマ1コマを変化させて動きを演出します。映画の場合は1コマは24分の1秒です。<br />
　ゲームの場合は、固定長のターンと可変長のターンがあります。<b>DxBase2016</b>の場合は、デフォルトは可変長のターンです。Windowsマシンは、CPUやアクセラレータのスペックによりマシンごとの処理速度が異なります。そのため、ターンの間隔を計算に入れないと、速いマシンと遅いマシンとの間にスピードが変わってしまいます。<br />
　その差を埋めるのが
<div class="box1">
<pre>
    //前回のターンからの経過時間を求める
    float ElapsedTime = App::GetApp()->GetElapsedTime();
</pre>
</div>
　で取得している<b>ElapsedTime</b>です。これは<b>前回のターンからの経過時間</b>が取得できます。この値を状態変化の計算に反映させることで、マシンごとによる動作速度の違いを吸収します。<br />
　位置の変化は、<b>現在のポジションを取り出して、変化をさせた後、変化後のポジションを設定する</b>というコードを記述します。<br />
　それを行っているのが
<div class="box1">
<pre>
        //位置の取得
        auto Pos = PtrTransform->GetPosition();
        //値を変化させる
        Pos.x += m_Span * ElapsedTime;
        if (abs(Pos.x) > 3.0f){
            //もし左右3.0を超えたら反転
            m_Span *= -1.0f;
        }
        //新しい位置を設定
        PtrTransform->SetPosition(Pos);
</pre>
</div>
　ということです。<br />
<br />
</div>
<!-- /コンテンツ　-->
<hr>
<!-- フッタ　-->
<ul class="foot_navi">
<li><a href="00_02.html">前ページ</a></li>
<li><a href="index.html">目次</a></li>
<li><a href="00_04.html">次ページ</a></li>
</ul>
<!-- /フッタ　-->


</div>
<!-- /全体コンテナ　-->
</body>
</html>
